// Code generated by protoc-gen-terraform. DO NOT EDIT.
// versions:
//   protoc-gen-gotf 0.1.3

package providerpb

import (
	"context"
	"fmt"

	"github.com/hashicorp/terraform-plugin-framework/datasource"
	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-log/tflog"
	"github.com/travix/gotf/dtsrc"
	"google.golang.org/grpc"

	pb "github.com/travix/gotf-example/pb"
)

// Ensure *GroupsDataSource fully satisfy terraform framework interfaces.
var _ datasource.DataSource = &GroupsDataSource{}

type GroupsDataSourceExec interface {
	dtsrc.Datasource[*pb.Groups]
	SetGroupServiceClient(pb.GroupServiceClient)
}

type GroupsDataSource struct {
	exec GroupsDataSourceExec
}

func NewGroupsDataSource(exec GroupsDataSourceExec) func() datasource.DataSource {
	if exec == nil {
		panic("GroupsDataSourceExec is required")
	}
	return func() datasource.DataSource {
		return &GroupsDataSource{exec: exec}
	}
}

func (d *GroupsDataSource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_groups"
	if _exec, ok := d.exec.(dtsrc.CanMetadata); ok {
		_exec.Metadata(ctx, req, resp)
	}
}

func (d *GroupsDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	resp.Schema = schema.Schema{
		MarkdownDescription: "terraform datasource",
		Attributes:          (&pb.Groups{}).DatasourceSchema(),
	}
	if _exec, ok := d.exec.(dtsrc.CanSchema); ok {
		_exec.Schema(ctx, req, resp)
	}
}

func (d *GroupsDataSource) Configure(ctx context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) {
	// Get the gRPC client connection from the ProviderData
	if req.ProviderData != nil {
		conn, ok := req.ProviderData.(grpc.ClientConnInterface)
		if !ok {
			resp.Diagnostics.AddError(
				"Unexpected ProviderData Type",
				fmt.Sprintf("Expected grpc.ClientConnInterface, got: %T. Please report this issue to the provider developers.", req.ProviderData),
			)
			return
		}
		// set the service clients
		d.exec.SetGroupServiceClient(pb.NewGroupServiceClient(conn))
	}
	if _exec, ok := d.exec.(dtsrc.CanConfigure); ok {
		_exec.Configure(ctx, req, resp)
		return
	}
}

func (d *GroupsDataSource) ConfigValidators(ctx context.Context) []datasource.ConfigValidator {
	if _exec, ok := d.exec.(dtsrc.CanConfigValidators); ok {
		return _exec.ConfigValidators(ctx)
	}
	tflog.Warn(ctx, "ConfigValidators method not implemented. Make sure argument to NewGroupsDataSource() implements dtsrc.CanConfigValidators interface")
	return nil
}

func (d *GroupsDataSource) ValidateConfig(ctx context.Context, req datasource.ValidateConfigRequest, resp *datasource.ValidateConfigResponse) {
	if _exec, ok := d.exec.(dtsrc.CanValidateConfig); ok {
		_exec.ValidateConfig(ctx, req, resp)
		return
	}
	tflog.Warn(ctx, "ValidateConfig method not implemented. Make sure argument to NewGroupsDataSource() implements dtsrc.CanValidateConfig interface")
}

func (d *GroupsDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {
	var data pb.Groups
	resp.Diagnostics.Append(req.Config.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}
	read, diagnostics := d.exec.Read(ctx, req, resp, &data)
	if diagnostics.HasError() {
		resp.Diagnostics.Append(diagnostics...)
		return
	}
	// Save data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, read)...)
}
